// /*
// Copyright The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// */
// Code generated by goyacc -o azure_security_group_shared_rulename.go -p NSGSharedRule azure_security_group_shared_rulename.y. DO NOT EDIT.

//line azure_security_group_shared_rulename.y:18
package provider

import (
	"fmt"
	__yyfmt__ "fmt"
	"strings"
	"unicode/utf8"
)

//line azure_security_group_shared_rulename.y:18

//line azure_security_group_shared_rulename.y:27
type NSGSharedRuleSymType struct {
	yys                 int
	DestinationPrefixes map[string]map[string]map[string]struct{}
	NamespaceLists      map[string]map[string]struct{}
	ServiceLists        map[string]struct{}
	String              string
}

var NSGSharedRuleToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"','",
	"';'",
	"'&'",
	"'0'",
	"'1'",
	"'2'",
	"'3'",
	"'4'",
	"'5'",
	"'6'",
	"'7'",
	"'8'",
	"'9'",
	"'a'",
	"'b'",
	"'c'",
	"'d'",
	"'e'",
	"'f'",
	"'g'",
	"'h'",
	"'i'",
	"'j'",
	"'k'",
	"'l'",
	"'m'",
	"'n'",
	"'o'",
	"'p'",
	"'q'",
	"'r'",
	"'s'",
	"'t'",
	"'u'",
	"'v'",
	"'w'",
	"'x'",
	"'y'",
	"'z'",
	"'A'",
	"'B'",
	"'C'",
	"'D'",
	"'E'",
	"'F'",
	"'-'",
	"'['",
	"']'",
	"'.'",
	"':'",
	"'/'",
}

var NSGSharedRuleStatenames = [...]string{}

const NSGSharedRuleEofCode = 1
const NSGSharedRuleErrCode = 2
const NSGSharedRuleInitialStackSize = 16

//line azure_security_group_shared_rulename.y:178

// The parser expects the lexer to return 0 on EOF.  Give it a name
// for clarity.
const eof = 0

// The parser uses the type SecurityGroupSharedRuleNameLexerImpl as a lexer. It must provide
// the methods Lex(*<prefix>SymType) int and Error(string).
type SecurityGroupSharedRuleNameLexerImpl struct {
	line                []byte
	peek                rune
	DestinationPrefixes map[string]map[string]map[string]struct{}
	Errs                []error
}

// The parser calls this method to get each new token. This
// implementation returns operators and NUM.
func (x *SecurityGroupSharedRuleNameLexerImpl) Lex(yylval *NSGSharedRuleSymType) int {
	for {
		c := x.next()
		switch c {
		case eof:
			return eof
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', ':', '/', ',', ';', '&', '.', '-':
			return int(c)
		case ' ', '\t', '\n', '\r':
			// ignore whitespace
		default:
			x.Errs = append(x.Errs, fmt.Errorf("unexpected character %q", c))
		}
	}
}

// Return the next rune for the lexer.
func (x *SecurityGroupSharedRuleNameLexerImpl) next() rune {
	if x.peek != eof {
		r := x.peek
		x.peek = eof
		return r
	}
	if len(x.line) == 0 {
		return eof
	}
	c, size := utf8.DecodeRune(x.line)
	x.line = x.line[size:]
	if c == utf8.RuneError && size == 1 {
		return x.next()
	}
	return c
}

// The parser calls this method on a parse error.
func (x *SecurityGroupSharedRuleNameLexerImpl) Error(s string) {
	x.Errs = append(x.Errs, fmt.Errorf("syntax error: %s", s))
}

//line yacctab:1
var NSGSharedRuleExca = [...]int8{
	-1, 1,
	1, -1,
	5, 3,
	-2, 15,
	-1, 51,
	4, 13,
	5, 13,
	6, 13,
	54, 13,
	-2, 15,
	-1, 64,
	4, 14,
	5, 14,
	6, 14,
	54, 14,
	-2, 16,
}

const NSGSharedRulePrivate = 57344

const NSGSharedRuleLast = 439

var NSGSharedRuleAct = [...]int8{
	46, 37, 38, 39, 40, 41, 42, 43, 44, 45,
	11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
	21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
	31, 32, 33, 34, 35, 36, 9, 55, 6, 56,
	5, 54, 10, 51, 47, 3, 2, 72, 46, 37,
	38, 39, 40, 41, 42, 43, 44, 45, 11, 12,
	13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
	23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
	33, 34, 35, 36, 50, 1, 0, 0, 0, 0,
	10, 51, 51, 51, 64, 71, 46, 37, 38, 39,
	40, 41, 42, 43, 44, 45, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
	25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
	35, 36, 48, 0, 0, 0, 0, 0, 10, 0,
	61, 7, 8, 46, 37, 38, 39, 40, 41, 42,
	43, 44, 45, 11, 12, 13, 14, 15, 16, 17,
	18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
	28, 29, 30, 31, 32, 33, 34, 35, 36, 0,
	0, 0, 0, 0, 0, 10, 0, 60, 0, 68,
	46, 37, 38, 39, 40, 41, 42, 43, 44, 45,
	11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
	21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
	31, 32, 33, 34, 35, 36, 0, 0, 0, 0,
	0, 0, 10, 0, 0, 0, 59, 46, 37, 38,
	39, 40, 41, 42, 43, 44, 45, 11, 12, 13,
	14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
	34, 35, 36, 0, 0, 0, 0, 0, 0, 10,
	0, 0, 67, 46, 37, 38, 39, 40, 41, 42,
	43, 44, 45, 11, 12, 13, 14, 15, 16, 17,
	18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
	28, 29, 30, 31, 32, 33, 34, 35, 36, 0,
	0, 0, 0, 0, 0, 10, 0, 0, 58, 46,
	37, 38, 39, 40, 41, 42, 43, 44, 45, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 4, 49, 0, 0, 0,
	0, 10, 0, 52, 53, 46, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
	26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
	36, 0, 0, 0, 0, 0, 0, 57, 0, 0,
	0, 0, 62, 63, 65, 66, 0, 0, 0, 0,
	0, 0, 0, 69, 70, 0, 0, 73, 74,
}

var NSGSharedRulePact = [...]int16{
	-1000, -1000, 35, -15, 89, -1000, 368, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 37, -1000, -17,
	33, -1000, 276, 183, 368, 368, 368, 322, -1000, -1000,
	-1000, 33, -1000, -1000, -1000, 230, 136, -1000, -1000, 41,
	-7, -1000, -1000, 322, 322,
}

var NSGSharedRulePgo = [...]int16{
	0, 85, 46, 45, 366, 36, 365, 84, 132, 44,
}

var NSGSharedRuleR1 = [...]int8{
	0, 1, 1, 2, 2, 3, 3, 9, 9, 8,
	8, 7, 7, 4, 4, 6, 6, 6, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5,
}

var NSGSharedRuleR2 = [...]int8{
	0, 0, 3, 0, 3, 9, 9, 3, 1, 3,
	1, 1, 3, 1, 3, 0, 2, 2, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1,
}

var NSGSharedRuleChk = [...]int16{
	-1000, -1, -2, -3, -6, 5, 53, 52, 53, -5,
	49, 17, 18, 19, 20, 21, 22, 23, 24, 25,
	26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
	36, 37, 38, 39, 40, 41, 42, 8, 9, 10,
	11, 12, 13, 14, 15, 16, 7, -9, -8, -4,
	-7, -5, -6, -6, 4, 54, 6, -6, 52, 53,
	-8, -7, -4, -4, -5, -6, -6, 52, 53, -6,
	-6, 54, 54, -6, -6,
}

var NSGSharedRuleDef = [...]int8{
	1, -2, 0, 0, 0, 2, 0, 15, 15, 16,
	17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
	27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
	37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
	47, 48, 49, 50, 51, 52, 53, 4, 8, 11,
	10, -2, 0, 0, 0, 0, 0, 0, 15, 15,
	7, 9, 11, 12, -2, 0, 0, 15, 15, 0,
	0, 15, 15, 5, 6,
}

var NSGSharedRuleTok1 = [...]int8{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 6, 3,
	3, 3, 3, 3, 4, 49, 52, 54, 7, 8,
	9, 10, 11, 12, 13, 14, 15, 16, 53, 5,
	3, 3, 3, 3, 3, 43, 44, 45, 46, 47,
	48, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 50, 3, 51, 3, 3, 3, 17, 18, 19,
	20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
	30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
	40, 41, 42,
}

var NSGSharedRuleTok2 = [...]int8{
	2, 3,
}

var NSGSharedRuleTok3 = [...]int8{
	0,
}

var NSGSharedRuleErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	NSGSharedRuleDebug        = 0
	NSGSharedRuleErrorVerbose = false
)

type NSGSharedRuleLexer interface {
	Lex(lval *NSGSharedRuleSymType) int
	Error(s string)
}

type NSGSharedRuleParser interface {
	Parse(NSGSharedRuleLexer) int
	Lookahead() int
}

type NSGSharedRuleParserImpl struct {
	lval  NSGSharedRuleSymType
	stack [NSGSharedRuleInitialStackSize]NSGSharedRuleSymType
	char  int
}

func (p *NSGSharedRuleParserImpl) Lookahead() int {
	return p.char
}

func NSGSharedRuleNewParser() NSGSharedRuleParser {
	return &NSGSharedRuleParserImpl{}
}

const NSGSharedRuleFlag = -1000

func NSGSharedRuleTokname(c int) string {
	if c >= 1 && c-1 < len(NSGSharedRuleToknames) {
		if NSGSharedRuleToknames[c-1] != "" {
			return NSGSharedRuleToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func NSGSharedRuleStatname(s int) string {
	if s >= 0 && s < len(NSGSharedRuleStatenames) {
		if NSGSharedRuleStatenames[s] != "" {
			return NSGSharedRuleStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func NSGSharedRuleErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !NSGSharedRuleErrorVerbose {
		return "syntax error"
	}

	for _, e := range NSGSharedRuleErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + NSGSharedRuleTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(NSGSharedRulePact[state])
	for tok := TOKSTART; tok-1 < len(NSGSharedRuleToknames); tok++ {
		if n := base + tok; n >= 0 && n < NSGSharedRuleLast && int(NSGSharedRuleChk[int(NSGSharedRuleAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if NSGSharedRuleDef[state] == -2 {
		i := 0
		for NSGSharedRuleExca[i] != -1 || int(NSGSharedRuleExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; NSGSharedRuleExca[i] >= 0; i += 2 {
			tok := int(NSGSharedRuleExca[i])
			if tok < TOKSTART || NSGSharedRuleExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if NSGSharedRuleExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += NSGSharedRuleTokname(tok)
	}
	return res
}

func NSGSharedRulelex1(lex NSGSharedRuleLexer, lval *NSGSharedRuleSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(NSGSharedRuleTok1[0])
		goto out
	}
	if char < len(NSGSharedRuleTok1) {
		token = int(NSGSharedRuleTok1[char])
		goto out
	}
	if char >= NSGSharedRulePrivate {
		if char < NSGSharedRulePrivate+len(NSGSharedRuleTok2) {
			token = int(NSGSharedRuleTok2[char-NSGSharedRulePrivate])
			goto out
		}
	}
	for i := 0; i < len(NSGSharedRuleTok3); i += 2 {
		token = int(NSGSharedRuleTok3[i+0])
		if token == char {
			token = int(NSGSharedRuleTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(NSGSharedRuleTok2[1]) /* unknown char */
	}
	if NSGSharedRuleDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", NSGSharedRuleTokname(token), uint(char))
	}
	return char, token
}

func NSGSharedRuleParse(NSGSharedRulelex NSGSharedRuleLexer) int {
	return NSGSharedRuleNewParser().Parse(NSGSharedRulelex)
}

func (NSGSharedRulercvr *NSGSharedRuleParserImpl) Parse(NSGSharedRulelex NSGSharedRuleLexer) int {
	var NSGSharedRulen int
	var NSGSharedRuleVAL NSGSharedRuleSymType
	var NSGSharedRuleDollar []NSGSharedRuleSymType
	_ = NSGSharedRuleDollar // silence set and not used
	NSGSharedRuleS := NSGSharedRulercvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	NSGSharedRulestate := 0
	NSGSharedRulercvr.char = -1
	NSGSharedRuletoken := -1 // NSGSharedRulercvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		NSGSharedRulestate = -1
		NSGSharedRulercvr.char = -1
		NSGSharedRuletoken = -1
	}()
	NSGSharedRulep := -1
	goto NSGSharedRulestack

ret0:
	return 0

ret1:
	return 1

NSGSharedRulestack:
	/* put a state and value onto the stack */
	if NSGSharedRuleDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", NSGSharedRuleTokname(NSGSharedRuletoken), NSGSharedRuleStatname(NSGSharedRulestate))
	}

	NSGSharedRulep++
	if NSGSharedRulep >= len(NSGSharedRuleS) {
		nyys := make([]NSGSharedRuleSymType, len(NSGSharedRuleS)*2)
		copy(nyys, NSGSharedRuleS)
		NSGSharedRuleS = nyys
	}
	NSGSharedRuleS[NSGSharedRulep] = NSGSharedRuleVAL
	NSGSharedRuleS[NSGSharedRulep].yys = NSGSharedRulestate

NSGSharedRulenewstate:
	NSGSharedRulen = int(NSGSharedRulePact[NSGSharedRulestate])
	if NSGSharedRulen <= NSGSharedRuleFlag {
		goto NSGSharedRuledefault /* simple state */
	}
	if NSGSharedRulercvr.char < 0 {
		NSGSharedRulercvr.char, NSGSharedRuletoken = NSGSharedRulelex1(NSGSharedRulelex, &NSGSharedRulercvr.lval)
	}
	NSGSharedRulen += NSGSharedRuletoken
	if NSGSharedRulen < 0 || NSGSharedRulen >= NSGSharedRuleLast {
		goto NSGSharedRuledefault
	}
	NSGSharedRulen = int(NSGSharedRuleAct[NSGSharedRulen])
	if int(NSGSharedRuleChk[NSGSharedRulen]) == NSGSharedRuletoken { /* valid shift */
		NSGSharedRulercvr.char = -1
		NSGSharedRuletoken = -1
		NSGSharedRuleVAL = NSGSharedRulercvr.lval
		NSGSharedRulestate = NSGSharedRulen
		if Errflag > 0 {
			Errflag--
		}
		goto NSGSharedRulestack
	}

NSGSharedRuledefault:
	/* default state action */
	NSGSharedRulen = int(NSGSharedRuleDef[NSGSharedRulestate])
	if NSGSharedRulen == -2 {
		if NSGSharedRulercvr.char < 0 {
			NSGSharedRulercvr.char, NSGSharedRuletoken = NSGSharedRulelex1(NSGSharedRulelex, &NSGSharedRulercvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if NSGSharedRuleExca[xi+0] == -1 && int(NSGSharedRuleExca[xi+1]) == NSGSharedRulestate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			NSGSharedRulen = int(NSGSharedRuleExca[xi+0])
			if NSGSharedRulen < 0 || NSGSharedRulen == NSGSharedRuletoken {
				break
			}
		}
		NSGSharedRulen = int(NSGSharedRuleExca[xi+1])
		if NSGSharedRulen < 0 {
			goto ret0
		}
	}
	if NSGSharedRulen == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			NSGSharedRulelex.Error(NSGSharedRuleErrorMessage(NSGSharedRulestate, NSGSharedRuletoken))
			Nerrs++
			if NSGSharedRuleDebug >= 1 {
				__yyfmt__.Printf("%s", NSGSharedRuleStatname(NSGSharedRulestate))
				__yyfmt__.Printf(" saw %s\n", NSGSharedRuleTokname(NSGSharedRuletoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for NSGSharedRulep >= 0 {
				NSGSharedRulen = int(NSGSharedRulePact[NSGSharedRuleS[NSGSharedRulep].yys]) + NSGSharedRuleErrCode
				if NSGSharedRulen >= 0 && NSGSharedRulen < NSGSharedRuleLast {
					NSGSharedRulestate = int(NSGSharedRuleAct[NSGSharedRulen]) /* simulate a shift of "error" */
					if int(NSGSharedRuleChk[NSGSharedRulestate]) == NSGSharedRuleErrCode {
						goto NSGSharedRulestack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if NSGSharedRuleDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", NSGSharedRuleS[NSGSharedRulep].yys)
				}
				NSGSharedRulep--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if NSGSharedRuleDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", NSGSharedRuleTokname(NSGSharedRuletoken))
			}
			if NSGSharedRuletoken == NSGSharedRuleEofCode {
				goto ret1
			}
			NSGSharedRulercvr.char = -1
			NSGSharedRuletoken = -1
			goto NSGSharedRulenewstate /* try again in the same state */
		}
	}

	/* reduction by production NSGSharedRulen */
	if NSGSharedRuleDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", NSGSharedRulen, NSGSharedRuleStatname(NSGSharedRulestate))
	}

	NSGSharedRulent := NSGSharedRulen
	NSGSharedRulept := NSGSharedRulep
	_ = NSGSharedRulept // guard against "declared and not used"

	NSGSharedRulep -= int(NSGSharedRuleR2[NSGSharedRulen])
	// NSGSharedRulep is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if NSGSharedRulep+1 >= len(NSGSharedRuleS) {
		nyys := make([]NSGSharedRuleSymType, len(NSGSharedRuleS)*2)
		copy(nyys, NSGSharedRuleS)
		NSGSharedRuleS = nyys
	}
	NSGSharedRuleVAL = NSGSharedRuleS[NSGSharedRulep+1]

	/* consult goto table to find next state */
	NSGSharedRulen = int(NSGSharedRuleR1[NSGSharedRulen])
	NSGSharedRuleg := int(NSGSharedRulePgo[NSGSharedRulen])
	NSGSharedRulej := NSGSharedRuleg + NSGSharedRuleS[NSGSharedRulep].yys + 1

	if NSGSharedRulej >= NSGSharedRuleLast {
		NSGSharedRulestate = int(NSGSharedRuleAct[NSGSharedRuleg])
	} else {
		NSGSharedRulestate = int(NSGSharedRuleAct[NSGSharedRulej])
		if int(NSGSharedRuleChk[NSGSharedRulestate]) != -NSGSharedRulen {
			NSGSharedRulestate = int(NSGSharedRuleAct[NSGSharedRuleg])
		}
	}
	// dummy call; replaced with literal code
	switch NSGSharedRulent {

	case 1:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-0 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:47
		{
			NSGSharedRulelex.(*SecurityGroupSharedRuleNameLexerImpl).DestinationPrefixes = nil
			NSGSharedRuleVAL.DestinationPrefixes = NSGSharedRulelex.(*SecurityGroupSharedRuleNameLexerImpl).DestinationPrefixes
		}
	case 2:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-3 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:52
		{
			NSGSharedRulelex.(*SecurityGroupSharedRuleNameLexerImpl).DestinationPrefixes = make(map[string]map[string]map[string]struct{})
			if NSGSharedRuleDollar[1].DestinationPrefixes != nil {
				for k, v := range NSGSharedRuleDollar[1].DestinationPrefixes {
					NSGSharedRulelex.(*SecurityGroupSharedRuleNameLexerImpl).DestinationPrefixes[k] = v
				}
			}
			if NSGSharedRuleDollar[2].DestinationPrefixes != nil {
				for k, v := range NSGSharedRuleDollar[2].DestinationPrefixes {
					NSGSharedRulelex.(*SecurityGroupSharedRuleNameLexerImpl).DestinationPrefixes[k] = v
				}
			}
			NSGSharedRuleVAL.DestinationPrefixes = NSGSharedRulelex.(*SecurityGroupSharedRuleNameLexerImpl).DestinationPrefixes
		}
	case 3:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-0 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:69
		{
			NSGSharedRuleVAL.DestinationPrefixes = nil
		}
	case 4:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-3 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:73
		{
			NSGSharedRuleVAL.DestinationPrefixes = make(map[string]map[string]map[string]struct{})
			NSGSharedRuleVAL.DestinationPrefixes[strings.ToLower(NSGSharedRuleDollar[1].String)] = NSGSharedRuleDollar[3].NamespaceLists
		}
	case 7:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-3 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:84
		{
			NSGSharedRuleVAL.NamespaceLists = make(map[string]map[string]struct{})
			for k, v := range NSGSharedRuleDollar[1].NamespaceLists {
				NSGSharedRuleVAL.NamespaceLists[k] = v
			}
			for k, v := range NSGSharedRuleDollar[3].NamespaceLists {
				NSGSharedRuleVAL.NamespaceLists[k] = v
			}
		}
	case 8:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-1 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:94
		{
			NSGSharedRuleVAL.NamespaceLists = make(map[string]map[string]struct{})
			for k, v := range NSGSharedRuleDollar[1].NamespaceLists {
				NSGSharedRuleVAL.NamespaceLists[k] = v
			}
		}
	case 9:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-3 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:103
		{
			NSGSharedRuleVAL.NamespaceLists = make(map[string]map[string]struct{})
			NSGSharedRuleVAL.NamespaceLists[strings.ToLower(NSGSharedRuleDollar[1].String)] = NSGSharedRuleDollar[3].ServiceLists
		}
	case 10:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-1 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:108
		{
			NSGSharedRuleVAL.NamespaceLists = make(map[string]map[string]struct{})
			NSGSharedRuleVAL.NamespaceLists[strings.ToLower("default")] = NSGSharedRuleDollar[1].ServiceLists
		}
	case 11:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-1 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:114
		{
			NSGSharedRuleVAL.ServiceLists = make(map[string]struct{})
			NSGSharedRuleVAL.ServiceLists[strings.ToLower(NSGSharedRuleDollar[1].String)] = struct{}{}
		}
	case 12:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-3 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:119
		{
			NSGSharedRuleVAL.ServiceLists = make(map[string]struct{})
			for k, v := range NSGSharedRuleDollar[1].ServiceLists {
				NSGSharedRuleVAL.ServiceLists[k] = v
			}
			NSGSharedRuleVAL.ServiceLists[strings.ToLower(NSGSharedRuleDollar[3].String)] = struct{}{}
		}
	case 15:
		NSGSharedRuleDollar = NSGSharedRuleS[NSGSharedRulept-0 : NSGSharedRulept+1]
//line azure_security_group_shared_rulename.y:133
		{
			NSGSharedRuleVAL.String = ""
		}
	}
	goto NSGSharedRulestack /* stack new state and value */
}
